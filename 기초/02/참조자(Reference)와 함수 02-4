2024/12/08

이번에는 참조자의 활용과 관련해서 이야기하고자 한다. 앞서 참조자의 이해를 위해서다음과 같은 코드를 수 차례 제시했는데,
이렇게 변수와 참조자를 동시에 선언할 필요가 있을까?

int num = 20;
int &ref = num;

이는 어디까지나 학슴을 위한 코드이다. 참조자의 활용에는 함수가 큰 위치를 차지한다.
따라서 함수와 관련해서 참조자를 이야기하고자 한다.

[Call - by - Value & Call - by - Reference]

우리가 C언어를 공부하면서 배운 함수의 두 가지 호출방식은 다음과 같다.

Call - by - Value              값을 인자로 전달하는 함수의 호출방식
Call - by - Reference          주소 값을 인자로 전달하는 함수의 호출방식

이 중에서, Call - by - Value 기반의 함수는 다음과 같이 정의된 함수를 의미한다.

int Adder(int num1, int num2)
{
    return num1+num2;
}

위 함수는 두 개의 정수를 인자로 요구하고 있다. 따라서 Call - by - Value 기반의 함수이다.
그런데, Call - by - Value의 형태로 정의된 함수의 내부에서는, 함수외부에 선언된 변수에 접근이 불가능하다.
따라서 두 변수에 저장된 값을 서로 바꿔서 저장할 목적으로 다음과 같이 함수를 정의하면 원하는 결과를 얻을 수 없다.

void SwapByValue(int num1, int num2)
{
    int temp = num1;
    num1 = num2;
    num2 = temp;
}  // Call - by - Value

위의 함수를 대상으로 다음의 main함수를 실행하면,

int main(void)
{
    int val1 = 10;
    int val2 = 20;
    SwapByValue(val1, val2);    // val1과 val2의 값이 바뀌길 기대
    cout << "val1 : " << val1 << endl;    // 10 출력
    cout << "val2 : " << val2 << endl;    // 20 출력
    return 0;
}

다음의 출력결과를 확인하게 된다.

val1 : 10
val2 : 20

그리고 이는 val1과 val2에 저장된 값이 서로 바뀌지 않았음을 의미한다. 그래서 필요한 것이 다음과 같은 Call - by - Reference 기반의 함수이다.

void SwapByRef(int * ptr1, int * ptr2)
{
    int temp = *ptr1;
    *ptr1 = *ptr2;
    *ptr1 = temp;
}    // Call - by - Reference

위의 함수에서는 두 개의 주소 값을 받아서, 그 주소 값이 참조하는 영역에 저장된 값을 직접 변경하고 이싿.
따라서 위 함수를 대상으로 다음의 main 함수를 실행하면,

int main(void)
{
    int val1 = 10;
    int val2 = 20;
    SwapByRef(&val1, &val2);
    cout << "val1 : " << val1 << endl;    // 20 출력
    cout << "val2 : " << val2 << endl;    // 10 출력
    return 0;
}

다음의 출력결과를 확인하게 된다.

val1 : 20
val2 : 10

[Call - by - Address? Call - by - Reference!]

최근 들어 주소 값을 전달하는 Call - by - Reference 형태의 함수호출이 Call - by - Address라 불리는 경우를 종종본다.
이는 잠시 후에 설명하는 'C++의 참조자(reference) 기반의 함수호출'과의 구분을 위함인데, 그럼에도 불구하고 채그이 필자는 이전의 방식, 
즉, 주소값을 전달하는 함수의 호출형태를 가리켜 여전히 Call - by - Reference 라 표현하고자 한다. 이유는 다음과 같다.

int * SimpleFunc(int * ptr)
{
    . . . 
}

여러분은 위의 함수정의가 Call - by - Value 라고 생가갛는가, 아니면 Call - by - Reference 라고 생각하는가?
대부분 Call - by - Reference 라고 생각할 것이다. 하지만 이는 Call - by - Value가 될 수 있고, Call - by - Reference도 될 수 있다.
다음가 같이 정의가 되면 이는 Call - by - Value라 해야 옳다.

int * SimpleFunc(int * ptr)
{
    return ptr + 1;    // 주소 값을 증가시켜서 반환
}

이 함수의 연산 주체는 값(value)이다. 다만 그 값이 주소 값 일뿐이다. 주소 값에 1을 더한 결과를 반환하는 연산을 하니(포인터 연산의 결과로 4증가)
흔히 우리가 생각하는, 주소 값을 이용해서 함수 외부에 선언된 변수에 접근하는 Call - by - Reference와 거리가 멀다.
반면 다음과 같이 정의가 되면, 이는 의심할 여지없이 Call - by - Reference이다.

int * SimpleFunc(int * ptr)
{
    if(ptr == NULL)
        return NULL;

    *ptr = 20;
    return ptr;
}

이 함수에서는 주소 값을 이용해서 함수 외부에 선언된 변수를 '참조(reference)'했으니, 이는 분명 Call - by - Reference이다.
본래 C언어에서 말하는 Call - by - Reference는 다음의 의미를 지닌다.

'주소 값을 전달받아서, 함수 외부에 선언된 변수에 접근하는 형태의 함수호출'

즉, 주소 값이 외부변수의 참조도구로 사용되는 함수의 호출을 뜻한다. 이렇듯 주소 값이 전달되었다는 사실이 중요한게 아니라,
주소 값이 참조의 도구로 사용되었다는 사실이 중요한 것이며, 이것이 Call - by - Value와 Call - by - Reference를 구분하는 기준이다.
C++에서는 함수 외부에 선언된 변수의 접근방법으로 두 가지가 존재한다. 하나는 ' 주소 값'을 이용하는 방식이고, 다른 하나는 '참조자'를 이용하는 방식이다.
따라서 이 책의 필자는 전통적인 방식을 따라 이 둘을 다음과 같이 구분하겠다.

주소 값을 이용한 Call - by - Reference
참조자를 이용한 Call - by - Reference

이렇듯 C++에서는 두 가지 방식으로 Call - by - Reference의 함수정의가 가능하다. 그리고 실제로 여러분든 이 둘 중 어떠한 방식을 사용할지 고민할것이다.

[
