2024/12/08

이번에는 참조자의 활용과 관련해서 이야기하고자 한다. 앞서 참조자의 이해를 위해서다음과 같은 코드를 수 차례 제시했는데,
이렇게 변수와 참조자를 동시에 선언할 필요가 있을까?

int num = 20;
int &ref = num;

이는 어디까지나 학슴을 위한 코드이다. 참조자의 활용에는 함수가 큰 위치를 차지한다.
따라서 함수와 관련해서 참조자를 이야기하고자 한다.

[Call - by - Value & Call - by - Reference]

우리가 C언어를 공부하면서 배운 함수의 두 가지 호출방식은 다음과 같다.

Call - by - Value              값을 인자로 전달하는 함수의 호출방식
Call - by - Reference          주소 값을 인자로 전달하는 함수의 호출방식

이 중에서, Call - by - Value 기반의 함수는 다음과 같이 정의된 함수를 의미한다.

int Adder(int num1, int num2)
{
    return num1+num2;
}

위 함수는 두 개의 정수를 인자로 요구하고 있다. 따라서 Call - by - Value 기반의 함수이다.
그런데, Call - by - Value의 형태로 정의된 함수의 내부에서는, 함수외부에 선언된 변수에 접근이 불가능하다.
따라서 두 변수에 저장된 값을 서로 바꿔서 저장할 목적으로 다음과 같이 함수를 정의하면 원하는 결과를 얻을 수 없다.

void SwapByValue(int num1, int num2)
{
    int temp = num1;
    num1 = num2;
    num2 = temp;
}  // Call - by - Value

위의 함수를 대상으로 다음의 main함수를 실행하면,

int main(void)
{
    int val1 = 10;
    int val2 = 20;
    SwapByValue(val1, val2);    // val1과 val2의 값이 바뀌길 기대
    cout << "val1 : " << val1 << endl;    // 10 출력
    cout << "val2 : " << val2 << endl;    // 20 출력
    return 0;
}

다음의 출력결과를 확인하게 된다.

val1 : 10
val2 : 20

그리고 이는 val1과 val2에 저장된 값이 서로 바뀌지 않았음을 의미한다. 그래서 필요한 것이 다음과 같은 Call - by - Reference 기반의 함수이다.

void SwapByRef(int * ptr1, int * ptr2)
{
    int temp = *ptr1;
    *ptr1 = *ptr2;
    *ptr1 = temp;
}    // Call - by - Reference

위의 함수에서는 두 개의 주소 값을 받아서, 그 주소 값이 참조하는 영역에 저장된 값을 직접 변경하고 이싿.
따라서 위 함수를 대상으로 다음의 main 함수를 실행하면,

int main(void)
{
    int val1 = 10;
    int val2 = 20;
    SwapByRef(&val1, &val2);
    cout << "val1 : " << val1 << endl;    // 20 출력
    cout << "val2 : " << val2 << endl;    // 10 출력
    return 0;
}

다음의 출력결과를 확인하게 된다.

val1 : 20
val2 : 10

[Call - by - Address? Call - by - Reference!]

최근 들어 주소 값을 전달하는 Call - by - Reference 형태의 함수호출이 Call - by - Address라 불리는 경우를 종종본다.
이는 잠시 후에 설명하는 'C++의 참조자(reference) 기반의 함수호출'과의 구분을 위함인데, 그럼에도 불구하고 채그이 필자는 이전의 방식, 
즉, 주소값을 전달하는 함수의 호출형태를 가리켜 여전히 Call - by - Reference 라 표현하고자 한다. 이유는 다음과 같다.

int * SimpleFunc(int * ptr)
{
    . . . 
}

여러분은 위의 함수정의가 Call - by - Value 라고 생가갛는가, 아니면 Call - by - Reference 라고 생각하는가?
대부분 Call - by - Reference 라고 생각할 것이다. 하지만 이는 Call - by - Value가 될 수 있고, Call - by - Reference도 될 수 있다.
다음가 같이 정의가 되면 이는 Call - by - Value라 해야 옳다.

int * SimpleFunc(int * ptr)
{
    return ptr + 1;    // 주소 값을 증가시켜서 반환
}

이 함수의 연산 주체는 값(value)이다. 다만 그 값이 주소 값 일뿐이다. 주소 값에 1을 더한 결과를 반환하는 연산을 하니(포인터 연산의 결과로 4증가)
흔히 우리가 생각하는, 주소 값을 이용해서 함수 외부에 선언된 변수에 접근하는 Call - by - Reference와 거리가 멀다.
반면 다음과 같이 정의가 되면, 이는 의심할 여지없이 Call - by - Reference이다.

int * SimpleFunc(int * ptr)
{
    if(ptr == NULL)
        return NULL;

    *ptr = 20;
    return ptr;
}

이 함수에서는 주소 값을 이용해서 함수 외부에 선언된 변수를 '참조(reference)'했으니, 이는 분명 Call - by - Reference이다.
본래 C언어에서 말하는 Call - by - Reference는 다음의 의미를 지닌다.

'주소 값을 전달받아서, 함수 외부에 선언된 변수에 접근하는 형태의 함수호출'

즉, 주소 값이 외부변수의 참조도구로 사용되는 함수의 호출을 뜻한다. 이렇듯 주소 값이 전달되었다는 사실이 중요한게 아니라,
주소 값이 참조의 도구로 사용되었다는 사실이 중요한 것이며, 이것이 Call - by - Value와 Call - by - Reference를 구분하는 기준이다.
C++에서는 함수 외부에 선언된 변수의 접근방법으로 두 가지가 존재한다. 하나는 ' 주소 값'을 이용하는 방식이고, 다른 하나는 '참조자'를 이용하는 방식이다.
따라서 이 책의 필자는 전통적인 방식을 따라 이 둘을 다음과 같이 구분하겠다.

주소 값을 이용한 Call - by - Reference
참조자를 이용한 Call - by - Reference

이렇듯 C++에서는 두 가지 방식으로 Call - by - Reference의 함수정의가 가능하다. 그리고 실제로 여러분든 이 둘 중 어떠한 방식을 사용할지 고민할것이다.


[참조자를 이용한 Call - by - Reference]

이미 설명하였듯이, C++에서는 참조자를 기반으로도 Call - by - Reference의 함수호출을 진행할 수 있다. 
Call - by - Reference의 가장 큰 핵심은 함수 내에서 함수외부에 선언된 변수에 접근할 수 있다는것이다.
하지만 이것은 참조자를 이용해서 함수를 정의해도 이런 일이 가능하다.

void SwapByRef2(int &ref1, int &ref2)
{
    int temp = ref1;
    ref1 = ref2;
    ref2 = temp;
}    // Call - by - Reference

매개변수의 선언 위치에 참조자가 와서 다소 당황했을 수 있다. 그리고 이런 질문을 할 수 있다.

'참조자는 선언과 동시에 변수로 초기화 되야한다면서요'

맞다, 하지만 매개변수는 함수가 호출되어야 초기화가 진행되는 변수들이다. 즉, 위의 매개변수 선언은 초기화가 이뤄지지 않은 것이 아니라,
함수호출 시 전달되는 인자로 초기화를 하겠다는 의미의 선언이다. 그럼 위의 함수를 대상으로 다음과 같이 함수를 호출하면 어떤 상황이 벌어질까?

int main(void)
{
    int val1 = 10;
    int val2 = 20;
    SwapByRef2(val1, val2);
    cout << "val1 : " val1 << endl;
    cout << "val2 : " val2 << endl;
    return 0;
}

실행결과를 예상하기 위해서는 함수가 호출된 순간 어떠한 일이 벌어지는지를 이해해야 한다.
이의 이해를 위해서 다음 그림을 참조하자

78페이지 그림 02-5

위 그림에서 보이는 바대로 매개변수로 선언된 참조자 ref1과 ref2는 main 함수에서 선언된 변수 val1과 val2의 또 다른 이름이 된다.
그리고 SwapByRef2 함수 내에서는 이 두 참조자를 통해서 값의 교환 과정을 거치기 때문에, 그 결과는 실제로 val1과 val2의 값의 교환으로 이어진다.
그럼 다음 예제를 통해서 함수의 호출결과를 확인해보자.

ex) RefSwap.cpp

#include <iostream>
using namespace std;

void SwapByRef2(int &ref1, int &ref2)
{
    int temp = ref1;        // 6행
    ref1 = ref2;
    ref2 = temp;            // 8행
}

int main(void)
{
    int val1 = 10;
    int val2 = 20;
    
    SwapByRef2(val1, val2);        // 16행
    cout << "val1 : " val1 << endl;
    cout << "val2 : " val2 << endl;
    return 0;
}

해설
6 ~ 8 행 : 두 참조자 ref1, ref2에 저장된 값의 교환과정이다. 이 교환의 과정은 main함수에 선언된 변수 val1과 val2의 교환으로 이어진다.
16 행 : 매개변수로 참조자가 선언되었으니, 참조의 대상이 될 변수를 인자로 전달하면 된다.

결과
val1 : 20
val2 : 10

실행결과는 앞서 이야기한 내용이 옳았음을 증명한다. 이렇듯 C++에는 Call - by -Reference의 구현 방법에 참조자를 이용하는 방법과 주소 값을 이용하는 방법, 이렇게 두 가지가 있다.


[참조자를 이용한 Call - by -Reference의 황당함과 const 참조자]

포인터는 잘못 사용할 확률이 높고, 참조자의 활용이 상대적으로 포인터의 활용보다 쉽기 때문에, 참조자 기반의 함수정의가 더 좋은 선택이라고 생각할 수 있다.
그러나 참조자 기반의 함수정의에 좋은 점만 있는 것은 아니다. 이와 관련해서 아래의 코드를 보자.

int num = 24;
HapppyFunc(num);
cout << num << endl;

C언어의 관점에서는 100% 24가 출력된다. 하지만 C++에서는 얼마가 출력될지 알 수 없다. 함수가 다음과 같이 정의되어 있다면 24가 출력되겠지만,

void HappyFunc(int prm) { ... }

다음과 같이 정의되어 있다면, 참조자를 이용해서 num에 저장된 값을 변경할 수도 있는 일이다.

void HappyFunc(int &prm) { ... }

이게 참조자의 단점이라는 사실이다. 아마도 '이걸 단점이라고 할 수 있어?'라고 반문할 수도 있다. 그러나 이는 분명한 참조자의 단점이 된다.
예를 들어서 코드를 분석하는 과정에 있다면, 함수의 호출문장만 보고도 함수의 특성을 어느 정도 판단할 수 있어야 한다. 그러나 참조자를 사용하는 경우, 함수의 원형을 확인해야 하고,
확인결과 참조자가 매개변수의 선언에 와있다면, 함수의 몸체까지 문장단위로 확인을 해서 참조자를 통한 값의 변경이 일어나는지를 확인해야 한다.
하지만 이런 단점은 완벽한 해결이 불가능하다. C언어에서는 호출문장만 보고도 값의 변경 유무를 확인 할 수 있지만, C++에서는 최소한 함수의 원형은 확인해야 한다.
따라서 완벽한 해결을 원한다면, 참조자 기반의 함수정의를 하지 말아야 한다. 그러나 const 키워드를 이용하면, 이러한 단점을 어느 정도는 극복할 수 있다. 다음의 함수원형을 보자

void HappyFunc(const int &ref) { ... }

참조자 ref에 const 선언이 추가되었다. 이는 다음의 의미를 지닌다.

'함수 HappyFunc 내에서 참조자 ref를 이용한 값의 변경은 하지 않겠다'

여기서의 const 선언으로 인해서, 참조자 ref에 값을 저장하는 경우 첨파일 에러가 발생한다. 따라서 함수 내에서 값의 변경이 이뤄지지 않음을 확신할 수 있다. 이렇게 하면 위에서 말한 참조자의 단점을 어느정도 해결할 수 있다.
따라서 다음의 원칙을 정하고 가급적 이 원칙을 지켜보자.

'함수 내에서, 참조자를 통한 값의 변경을 진행하지 않을 경우, 참조자를 const로 선언해서, 함수의 원형만 봐도 값의 변경이 이뤄지지 않음을 알 수 있게 하자'


[반환형이 참조형(Reference Type)인 경우]

함수의 반환형에도 참조형이 선언될 수 이삳. 다음이 가장 대표적인 경우이다.

int& RefRetRuncOne(int &ref)
{
    ref++;
    return ref;
}

위의 함수에서는매개변수로 참조자가 선언되었는데, 이 참조자를 그대로 반환하고 있다. 따라서 다음과 같이 생각할 수 있다.

'매개변수가 참조자인데, 이를 반환하니까 반환형이 참조형인 거구나'

하지만 이는 잘못된 판단이다. 왜냐하면 다음과 같이 참조자를 반환해도 반환형은 참조형이 아닐 수 있기 때문이다.

int RefRetFuncTwo(int &ref)
{
    ref++;
    return ref;
}

이 둘의 차이점을 알겠는가? 어떤 차이가 있는지 상상해보자.
그리고 그 상상이 옳았는지 다음 예제를 통해서 확인해보자.

ex) RefReturnOne.cpp

#include <iostream>
using namespace std;

int& RefRetFuncOne(int &ref)
{
    ref++;
    return ref;
}

int main(void)
{
    int num1 = 1;
    int &num2 = RefRetFuncOne(num1);        // 13행

    num1++;                                // 15행
    num2++;                                // 16행
    cout << "num1 : " << num1 <<endl;        // 17행
    cout << "num2 : " << num2 <<endl;        // 18행
    return 0;
}

해설
13 행 : RefRetFuncOne 함수가 참조자를 반환했고, 이를 다시 참조자에 저장하고 있다.
15, 16 행 : 변수 num1과 참조자 num2의 값을 1씩 증가시키고 있다.
17, 18 행 : 변수 num1과 참조자 num2의 관계를 확인하기 위한 출력.

// 내 생각 : 자료형이 참조형인 함수를 정의하고 메인에서 변수 num1 선언 그리고 참조자 num2를 선언함과 동시에 함수호출(인수는 num1)
고로 참조자 num2가 함수가 RefRetFuncOne함수가 된 것.

결과
num1 : 4
num2 : 4

결과를 통해서 참조형의 반환이 어떤 의미를 지니는지 이해했는가??
위 예제를 통해서 보이고자 한 내용을 그림으로 확인해보자

84페이지 그림 02-6

그림에서 보이듯 참조형으로 반환된 값을 참조자에 저장하면, 참조의 관계가 하나 더 추가된다.
즉, 위 예제에서 보이는 상황은 다음과 동일하다.

int num1 = 1;
int &ref = num1;
int &num2 = ref;

그런데 여기서 한가지 기억할 사실이 있다. 함수 RefRetFuncOne의 매개변수로 선언된 참조자 ref는 지역변수와 동일한 성격을 가진다.
즉, RefRetFuncOne이 반환하면, 참조자 ref는 소멸한다. 그러나 참조자는 참조자일뿐, 그 자체로 변수는 아니기 때문에 참조자가 참조하는 변수는 소멸되지 않는다.
즉, 함수의 반환으로 인한 참조자의 소멸결과는 다음과 같다.

84페이지 그림 02-7
// 글로 설명하면 RefRetFuncOne 함수 반환 후  ref는 소멸하지만 num2는 남는다.

그럼 이번에는 예제 RefRetFuncOne.cpp의 13행을 다음과 같이 변경해보자. 어떤 결과가 나올까?

int num2 = RefRetFuncOne(num1)

참조자를 변수로 대신하였다. 흔히 하는 말로 '한끝 차'이기 때문에 조금 헷갈릴 수 있지만, 결과적으로 어떤 차이를 보이는지 우리도 판단이 가능하다.
예제를 통해서 차이점을 확인해보자.

ex) RefReturnTwo.cpp

#include <iostream>
using namespace std;

int& RefRetFuncOne(int &ref)        // RefRetFuncOne.cpp의 RefRetFuncOne과 동일
{
    ref++;
    return ref;
}

int main(void)
{
    int num1 = 1;
    int num2 = RefRetFuncOne(num1);        // 13행

    num1+=1;                                // 15행
    num2+=100;                              // 16행
    cout << "num1 :" << num1 << endl;
    cout << "num2 :" << num2 << endl;
    return 0;
}

해설
13 행 : 참조형으로 반환이 되지만, 이렇듯 참조자가 아닌 일반변수를 선언해서 반환값을 저장할 수 있다.
        여기서 중요한 점은 12행에 선언된 num1과 13행에 선언된 num2는 완전히 별개의 변수라는 것이다.
15, 16 행 : num1과 num2가 다른 변수임을 확인하기 위해서 서로 다른 연산을 진행.

// 내 생각 : RefRetFuncOne함수 정의 메인에서 num1 선언 및 1로 초기화 변수 num2 선언 및 RefRetFuncOne함수 호출 인수는 num1
하지만 여기서 num2이 참조자가 아닌 변수라 num1 과 num2가 각각 다른 변수로 선언됨. 14행까지 num1 과 num2 둘 다 같은 값인 2를 가지고 있지만 다른 변수이다.

결과
num1 : 3
num2 : 102

위 예제의 실행결과는 프로그램의 흐름이 다음과 같음을 증명한다.

86페이지 그림 02-8

위의 그림과 코드가 이해되는가? 위 예제에서 보이는 상황은 다음과 동일하다 . 다만 함수의 호출을 통해서 이 과정이 진행되었을 뿐이다.

int num1 = 1;
int &ref = num1;        // 인자의 전다로가정에서 일어난 일
int num2 = ref;        // 함수의 반환과 반환 값의 저장에서 일어난 일

이렇듯 반환형이 참조형인 경우, 반환 값을 무엇으로 저장하느냐에 따라서 그 결과에 차이가 있으므로, 적절한 선택을 해야만 한다. 이제 마지막으로 참조자를 반환하되,
반환형은 기본자료형인 경우를 설명하기 위해서 다음 예제를 제시한다.

ex) RefReturnThrre.cpp

#include <iostream>
using namesapce std;

int RefRetFuncTwo(int &ref)        // 반환형이 기본자료형 int이다.
{
    ref++;
    return ref;                    // 7행
}

int main(void)
{
    int num1 = 1;
    int num2 = RefRetFuncTwo(num1);

    num1 += 1;                        // 15행
    num2 += 100;                      // 16행
    cout << "num1 :" << num1 << endl;
    cout << "num2 :" << num2 << endl;
    return 0;
}

해설
7 행 : 참조자를 반환하지만, 반환형이 기본자료형 int이기 때문에 참조자가 참조하는 변수의 값이 반환된다.
        다시 말하지만, 변수에 저장된 값이 반환된다.
15, 16 행 : num1과 num2가 다른 변수임을 확인하기 위해 서로 다른 연산 진행

결과
num1 : 3
num2 : 102

실행결과를 보면 예제 RefReturnTwo.cpp 와 차이가 없다. 뿐만 아니라, 실행의 과정에서 일어나는 일도 그림 02 - 8과 동일하다.
하지만 다음의 차이가 이싿. 반환형이 참조형인 RefRetFuncOne 함수는 반환 값을 다음과 같이 두 가지 형태로 저장할 수 있다.
물론 각각의 경우가 어떻게 다른지는 앞서 예제를 통해 설명하겠다..

int num2 = RefRetFuncOne(num1);            O
int &num2 = RefRetFuncOne(num1);           O

하지만, 반환형이 기본자료형으로 선언된 RefRetFuncTwo 함수의 반환 값은 반드시 변수에 저장해야 한다.
반환 값은 상수나 다름없기 때문이다.

int num2 = RefRetFuncTwo(num1);            O
int &num2 = RefRetFuncTwo(num1);           X

지금까지 설명한 함수의 반환형에 대한 내용이 처음에는 다소 혼란스러울 수 이싿. 하지만, 익숙해지면 자연스럽게 받아들일 수 잇으니,
익숙해질 때까지 몇 차례 반복학습하자.


[잘못된 참조의 반환]

위에서 설명한 함수의 반환형에 대한 내용을 잘 이해해싿면, 다음 함수에 어떤 문제가 있는지 예상할 수 있을 것이다.

int& RetuRefFunc(int n)
{
    int num = 20;
    num += n;
    return num;
}

위의 함수에서는 지역변수 num에 저장된 값을 반환하지 않고, num을 참조의 형태로 반환하고 있다.
따라서 다음의 형태로 함수를 호출하고 나면,

int &ref = RetuRefFunc(10);

지역변수 num에 ref라는 또 하나의 이름이 붙게 된다. 하지만 이게 끝이 아니다. 함수가 반환이 되면, 정작 지역변수 num은 소멸이 된다.
따라서 위의 함수처럼 지역벼수를 참조형으로 반환하는 일은 없어야 한다.

'에이, 잘못 구현했다면, 컴파일러가 알아서 에러메세지를 던져주겠죠'

아니다. 컴파일러는 경고메세지를 띄울 뿐, 에러메세지를 띄워주지는 않는다. 뿐만 아니라, 아직 채 소멸되지 않은(그러나 곧 소멸될), 찌꺼기의 형태로
남아있는 데이터를 참조해서 우리가 기대하는 정상적인 결과를 보이기도 하니, 주의하자.


[const 참조자의 또 다른 특징]

앞서 const 참조자에 대해서 설명을 했는데, 이와 관련해서 보충할 내용이 있다.
먼저 다음 코드를 보고 논리적인 문제점을 찾아보자.

const int num = 20;
int &ref = num;
ref += 10;
cout << num << endl;

const 선언을 통해서 변수 num을 상수화했는데, 참조자 ref를 통해서 값을 변경한다? 이것을 허용한다면, 사실상 변수 num의 상수화는 의마가 없다.
상수화가 되었다면 어떠한 경로를 통하더라도 값의 변경을 허용하면 안된다. 다행히도 C++에서는 이를 허용하지 않는다.
위의 코드  중 다음 문장에서 컴파일에러를 일으키기 때문이다.

int &ref = num;

따라서 변수 nu과 같이 상수화된 변수에 대한 참조자 선언은 다음과 같이해야 한다.

const int num = 20;
const int &ref = num;

이렇게 선언이 되면 ref를 통한 값의 변경이 불가능하기 때문에 상수화에 대한 논리적인 문제점은 발생하지 않는다.
그리고 const 참조자는 다음과 같이 상수도 참조가 가능하다.

const int &ref = 50;

지금까지 참조자는 변수만 참조가 가능하다고 설명햇는데, 갑자기 상수의 참조를 논하니 어지러울 수 있다.
바로 밑에서 설명한다.

// 참고 : const 선언에 의해서 만들어진 변수를 가리켜 '상수화된 변수'라 한다. 본래 상수가 아니라, 변수를 상수화시킨 것으로 정의하고 있기 때문이다.


[어떻게 참조자가 상수를 참조하냐구요]

먼저 다음 문장을 봐보자

int num = 20+30;

여기서 20, 그리고 30과 같은 프로그램상 표현되는 숫자를 가리켜 '리터럴(literal)' 또는 '리터럴 상수(literal constant)'라 한다. 그리고 이들은 다음의 특징을 가진다.

'임시적으로 존재하는 값이다. 다음 행으로 넘어가면 존재하지 않는 상수다'

무슨 뜻인지 이해가 되는가? 덧셈연산을 위해서는 20도, 그리고 30도 모두 메모리 공간에 저장되어야 한다. 하지만 저장되었다고 해서 재 참조가 가능한 값은 아니다.
즉, 다음 행으로 넘어가면 소멸되는 상수라고 해도 틀리지 않는다. 그런데 이런 상수를 참조한다는 것이 이치에 맞는다고 생각하는가? 다음과 같이 말이다.

const int &ref = 30;

이는 숫자 30이 메모리 공간에 계속 남아있을 때에나 성립이 가능한 문장이다. 그래서 C++에서는 위의 문장이 성립할 수 잇도록, const 참조자를 이용해서 상수를 참조할 때 '임시변수'라는 것을 만든다.
그리고 이장소에 상수 30을 저장하고선 참조자가 이를 참조하게끔 한다.

90페이지 그림 02 - 9

이렇듯 임시로 생성한 변수를 상수화하여 이를 참조자가 참조하게끔 하는 구조이니, 결과적으로는 상수화된 변수를 참조하는 형태가 된다.

'왜 임시변수라는 잘 와닿지도 않는 개념까지 끌어들여서 상수의 참조가 가능하게 했을까?'

이는 다음 함수 하나로 답이 된다.

int Adder(const int &num1, const int &num2)
{
    return num1 + num2;
}

위와 같이 정의된 함수에 인자의 전달을 목적으로 변수를 선언한다는 것은 매우 번거로운 일이 아닐 수 없다. 그러나 임시변수의 생성을 통한 const 참조자의 상수참조를 허용함으로써,
위의 함수는 다음과 같이 매우 간단히 호출이 가능해졌다.

cout << Adder(3, 4) << endl;

책의 필자도 이런 형태의 함수호출이 가능하다는 것을 알리고자, 'const 참조자의 상수참조'를 설명한 것이다.

