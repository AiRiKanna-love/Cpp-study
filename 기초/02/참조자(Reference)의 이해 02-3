2024/12/07

지금부터 설명하는 '참조자'라는 것은 성격상 포인터와 비유가 되기 쉽다. 그러나 참조자는 포인터를 모르는 사람도 이해할 수 있는 개념이다.
따라서 포인터의 개념까지 끌어들여서 괴롭히지 말자? // 이거 어차피 포인터에서도 쓰이잖아..

[참조자(Reference)의 이해]

무엇을 가리켜 변수라 하는가? 다음은 우리가 잘 알고 있는 변수의 정의다.

'변수는 할당된 메모리 공간에 붙여진 이름이다. 그리고 그 이름을 통해서 해당 메모리 공간에 접근이 가능하다'

그렇다면 이렇게 생각해 볼 수도 있다

'할당된 하나의 메모리 공간에 둘 이상의 이름을 부여할 수는 없을까?'

솔직히 이런 생각을 할 필요가 뭐 있을까? 그러나 지금은 이런 생각을 한번쯤 해보자.
왜나면 이 질문이 참조자와 깊은 관계가 있기 때문이다. 그럼 먼저 참조자의 이해를 위해 변수 하나를 선언하자.

int num1 = 2021;

위의 변수 선언을 통해서 2021로 초기화 된 메모리 공간에 num1이라는 이름이 붙게 된다.

67페이지 그림

그런데 이 상황에서 다음의 문장을 실행하면, num1이라는 이름이 붙어있는 메모리 공간에는 num2라는 이름이 하나 더 붙게 된다.

int &num2 = num1;

이 문장은 다소 혼란스러울 수 잇다. 왜나하면 & 연산자는 변수의 주소 값을 반환하는 연산자이기 때문이다.
하지만 위의 문장에서 보이듯이 & 연산자는 전혀 다른 의미로도 사용이 된다. 
이미 선언된 변수의 앞에 이 연산자가 오면 주소 값을 반환을 명령하는 뜻이 되지만, 
새로 선언되는 변수의 이름앞에 등장하면 이는 '참조자'의 선언을 뜻하게 된다.

int *ptr = &num1;    // 변수 num1의 주소 값을 반환해서 포인터 ptr에 저장
int &num2 = num1;    // 변수 num1에 대한 참조자 num2 선언

따라서 변수 num1의 선언 이후에 다음 문장이 실행되면,

int &num2 = num1;

num2는 num1의 '참조자'가 되며, 이는 다음의 결과로 이어지게 된다.

69페이지 그림 02-2

결과적으로 num1이라 이름 붙어잇는 메모리 공간에 num2라는 이름이 하나 더 붙은 꼴이 된것이다.

'그럼 참조자도 변수인가요?'

사실상 변수로 봐도 무리는 없다. 잠시 후에 보이겠지만, 그 기능과 연산의 결과가 변수와 동일하다.
하지만, C++에서는 참조자와 변수를 구분해서 이야기한다. 이미 선언된 변수를 대상으로 만들어진 num2와 같은 것을 가리켜 변수라 하지 않고,
'참조자'라는 별도의 이름을 정의해 놓았다. 어쨋든, 결과적으로는 그림 02-2의 형태를 띠기 때문에, 이어서 다음의 문장을 실행하면

num2 = 3047;

변수 num1의 메모리 공간에 3047이 저장되어, 다음의 구조가 되며,

num1 = 3047
69페이지 그림 20-3

이어서 다음의 두 문장을 실행하면, 

cout << num1 << endl;
cout << num2 << endl;

두 번에 걸쳐서 3047이 출력되는 것을 확인할 수 있다. 이렇듯 참조자는 자신이 참조하는 변수를 대신할 수 있는 또 하나의 이름인 것이다.
예제를 통해서 설명한 내용을 직접 확인해보자.

ex) Referen.cpp

#include <iostream>
using namespace std;

int main(void)
{
    int num1 = 1020;
    int &num2 = num1;    // 7행

    num2 = 3047;
    cout << "Val : " << num1 << endl;    // 10행
    cout << "Ref : " << num2 << endl;    // 11행

    cout << "Val : " << &num1 << endl;    // 13행
    cout << "Ref : " << &num2 << endl;    // 14행
    return 0;
}

해설 
7 행 : num1에 대한 참조자 num2 선언. 따라서 이후로는 num1과 num2가 동일한 메모리 공간을 참조
10, 11 행 : 동일한 값이 출력되면, num1과 num2가 동일한 메모리 공간을 참조함을 증명하는 셈이다.
13, 14 행 : num1과 num2의 주소 값을 출력하게 하였다. // 이 결과값에 주목

결과
Val : 3047
Ref : 3047
Val : 0012FF60
Ref : 0012FF60

변수와 참조자는 선언의 방식에 있어서 확실한 차이를 보인다. 참조자는 변수를 대상으로만 선언이 가능하기 때문이다.
하지만 일단 선언이 되고 나면, 변수와 차이가 없다. 위 예제에서 보이듯이 & 연산자를 이용해서 주소 값을 반환 받을 수도 있고,
함수 내에서 선언된 지역적(local) 차몾자는 지역변수와 마찬가지로 함수를 빠져나가면 소멸된다.

[참조자는 별칭]

개념적으로 참조자를 이해했을 것이다. 그런데 전통적으로 C++에서는 참조자를 다음과 같이 설명한다

'변수에 별명을 하나 붙여주는 것이다'

즉, 다음의 선언에서,

int &num2 = num1;

num1이 변수의 이름이라면, num2는 num1의 별명이라는 뜻이다. 그런데, 이 역시 참조자를 이해하기 위한 좋은 비유가 된다.
예를 들어서 'AAA'라는 사람의 별명이'흰곰'이라면 다음 두 문장이 의미하는 바와 이 문장대로 처리했을 때의 결과는 모두 동일히다.

'AAA에게 전화해서 이리 오라해'
'흰곰에게 전화해서 이리 오라해'

이는 참조자에 대해 일반적인 설명에 해당하니, 참조자가 별명에 비유된다는 사실도 알아줬으면 좋겠다

[참조자의 수에는 제한이 없으며, 참조자를 대상으로 참조자를 선언할 수 있다]

참조자의 수에는 제한이 없다. 즉, 다음과 같이 여러 개의 참조자를 선언하는 것도 가능하다.

int num1 = 2759;
int &num2 = num1;
int &num3 = num1;
int &num4 = num1;

따라서 위의 문장들을 순서대로 실행하면, 하나의 메모리 공간에 num1, num2, num3, num4 라는 이름을 붙인 꼴이 된다.

그리고 참조자를 대상으로 참조자를 선언하는 것도 가능하다. 즉, 다음의 문장들을 순서대로 실행해도 결과는 같다.

int num1 = 2759;
int &num2 = num1;
int &num3 = num2;
int &num4 = num3;

하지만, 필요 이상으로 참조자를 선언하는 것은 바람직하지 않으며, 참조자를 대상으로 또 다른 참조를 만드는 일이 흔히 필요하지 않는다.

[참조자의 선언 가능 범위]

참조자는 변수에 대해서만 선언이 가능하고, 선언됨과 동시에 누군가를 참조해야만 한다. 즉, 다음의 문장은 유효하지 않는다.

int &ref = 20;    // X

참조자는 본디, 변수에 또 다른 이름을 붙이는 것이기 때문에 상수를 대상으로 참조자를 선언할 수는 없다.
뿐만 아니라, 다음과 같이 미리 참조자를 선언했다가, 후에 누군가를 참조하는 것은 불가능하며, 참조자의 대상을 바꾸는 것도 불가능하다.

int &ref;    // X

물론, 다음과 같이 참조자를 선언하면서 NULL로 초기화 하는것도 불가능 하다. 포인터 변수의 선언처럼 말이다.

int &ref = NULL;    // X

참조자는 무조건 선언과 동시에 변수를 참조하도록 해야 한다. 그런데 여기서 말하는 변수의 범위에는 배열요소도 포함이 된다. 
예제를 통해서 알아보자.

ex) RefArrElem.cpp

#include <iostream>
using namespace std;

int main(void)
{
    int arr[3] = {1, 3, 5};
    int &ref = arr[0];
    int &ref1 = arr[1];
    int &ref2 = arr[2];

    cout << ref << endl;
    cout << ref1 << endl;
    cout << ref2 << endl;
    return 0;

}

결과
1
3
5

예제와 실행결과에서 보이듯이 배열요소는(배열이 아니라, 배열의 요소는) 변수로 간주되어 참조자의 선언이 가능하다.
그리고 포인터 변수도 변수이기 때문에 참조자의 선언이 가능하다. 이와 관련해서도 예제를 통해서 설명

ex) RefPtr.cpp

#include <iostream>
using namespace std;

int main(void)
{
    int num = 12;
    int *ptr = &num;
    int **dptr = &ptr;

    int &ref = num;           // 10행
    int *(pref) = ptr;        // 11행
    int **(&dpref) = dptr;    // 12행

    cout << ref << endl;
    cout << *pref << endl;    // 15행
    cout << **dpref << endl;    // 16행
    return 0;
}

해설
11, 12 행 : 포인터 변수의 참조자 선언도 & 연산자를 하나 더 추가하는 형태로 진행이 된다.
            이미 잘 아는 10행의 참조자 선언과 비교해보자.
15 행 : pref는 포인터 변수 ptr의 참조자이므로, 변수 num에 저장된 값이 출력.
16 행 : dpref는 포인터 변수 dptr의 참조자이므로, 변수 num에 저장된 값이 출력.

결과
12
12
12

이제 참조자의 선언 가능 유무와 참조자의 선언 방법에 대한 규칙이 잘 정리되었으리라 믿고,
함수의 관계를 시작으로 참조자에 대한 조금 더 깊은 이야기를 시작해보자.
