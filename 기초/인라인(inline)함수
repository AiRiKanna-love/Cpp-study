2024/12/04

인라인(inline)함수
'inline 함수'를 의역하자면, '프로그램 코드라인 안으로 들어가 버린 함수' 라는 뜻

[매크로 함수의 장점]
매크로 함수의 대표적인 장점은 다음과 같다.

'일반적인 함수에 비해서 실행속도의 이점이 있다'

반면, 매크로 함수의 단점은 다음과 같다.

'정의하기가 어렵다. 복잡한 함수를 매크로의 형태로 정의하는데 한계가 있다'

예시

ex)
#define SQUARE(x) ((x)*(x))

int main(void)
{
  cout<< SQUARE(5) << endl;
  return 0;
}

위의 코드는 전처리 과정을 다음과 같이 변경된다. 여기서 중요한 점은 함수의 몸체부분이 함수의 호출문을 대체했다는 점이다.

ex)

int main(void)
{
  cout<< ((5)*(5))<<endl;
  return 0;
}

위 예제와 같이 함수의 몸체부분이 함수호출 문장을 완전히 대체했을 때 '함수가 인라인화 되었다'라고 표현한다.
그럼 다음과 같은 생각을 해 볼 수 있다.

'매크로 함수는 정의하기가 복잡하니, 일반 함수처럼 정의가 가능하면 좋겠다'

C++의 인라인 함수는 이런 요구사항을 만족한다.


[C++ 기반의 인라인 함수 정의]
아래의 예제에서 매크로 함수를 이용하지 않는, C++ 기반의 인라인 함수의 정의방법을 보이고 있다.

ex)

inline int SQUARE(int x)     // 3god
{
  return x * x;
}

int main(void)
{
  cout << SQUARE(5) << endl;    // 10행
  cout << SQUARE(12) << endl;    // 11행
  return 0;
}

해설
3행 : 인라인 함수의 정의 방법을 보이고 있다. 키워드 inline의 선언을 통해서 함수 SQUARE는 인라인 함수가 되었다.
10, 11행 : SQUARE 함수를 호출하고 있다. 그런데 이 함수는 인라인 함수이니 몸체부분이 호출문을 대체하게 된다.

결과
25
144

참고로 매크로를 이용한 함수의 인라인화는 전처리기에 의해서 처리되지만, 키워드 inline을 이용한 함수의 인라인화는 컴파일러에 의해서 처리된다.
따라서 컴파일러는 함수의 인러인화가 오히려 해가 된다고 판단할 경우, 이 키워드를 무시해 버리기도 한다. 또한 컴파일러가 필요한 경우 일부 함수를 임의로 인라인화 처리한다.


[매크로 함수에는 있지만, 인라인 함수에는 없는 장점]

사실 위의 인라인 함수는 매크로 함수의 장점을 완전히 대체하지 못했다.
예를 들어서 매크로 함수가 다음과 같이 정의된다면,

ex)

#define SQUARE(X) ((X)*(X))

이는 자료형에 의존적이지 않은 함수가 된다. 따라서 함수호출 문장은, 

cout << SQUARE(12);      // int형 함수호출
cout << SQUARE(3.15);    // double형 함수호출

다음과 같이 변환이 이뤄져서 어떠한 경우에도 데이터의 손실이 발생하지 않는다.

cout << ((12)*(12));        // int형 함수호출
cout << ((3.15)*(3.15));   // double형 함수호출

하지만 다음과 같이 정의된 인라인 함수는, 

inline int SQUARE(int x) { return x * x; }

int형 기반으로 정의된 함수이기 때문에 다음의 함수호출 문장에서 데이터 손실이 발생한다.

cout << SQUARE(3.15);      // 0.15가 손실되어서 3 x 3의 결과인 9가 출려된다.

물론 함수의 오버로딩을 통해서 이 문제를 해결할 수는 있으나, 그렇게 되면 여러 개의 함수를 추가로 정의하는 꼴이니, 한번만 정의하면 되는 매크로 함수의 장점과는 거리가 멀어지게 된다.
그러나 C++의 템플릿 이라는 것을 이용하면 매크로 함수와 마찬가지로 자료형에 의존적이지 않은 함수가 완성된다.


템플릿은 한~참 뒤에나 공부하니 예제만 봐보자

#incldue <iostream>
using namespace std;

template <typename T>
inline T SQUARE(T x)
{
  return x * x; 
}

int main(void)
{
  cout << SQUARE(5.5) << endl;
  cout << SQUARE(12) << endl;
  return 0;
}

위의 코드를 실행해보면, 데이터의 손실이 발생하지 않음을 알 수 있다.
