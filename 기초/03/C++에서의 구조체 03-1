2024/12/16

우리가 이미 구조체를 잘 알고 있다고 가정하고 이야기를 이어가겠다. 따라서 구조체에 대한 이해가 부족하다면, 잠시 이 책을 접어두고 구조체를 먼저 공부하기 바란다.


[구조체의 등장배경은 무엇인가?]

C언어로 프로그램을 구현한다면, 구조체의 정의는 항상 뒤를 따르기 마련이다. 그렇다면 구조체가 주는 이점이 무엇이기에 이렇듯 중요한 위치를 차지하고 있는걸까?
이와 유사한 질문에 선배 프로그래머들에게 한다면, 다양한 답변이 나올 것이다. 그러나 그 이면에는 다음의 내용이 공통분모로 자리잡고 있다.

  '연관 있는 데이터를 하나로 묶으면, 프로그램의 구현 및 관리가 용이하다.'

소프트웨어를 단순히 표현하면 다음과 같다.

  '소프트웨어 = 데이터의 표현 + 데이터의 처리'

그런데 '표현해야 하는 데이터'는 항상 부류를 형성하기 마련이다. 그리고 이렇게 부류를 형성하는 데이터들은 함께 생성, 이동 및 소멸되낟는 특성이 있다. 그래서
구조체는 연관 있는 데이터를 묶을 수 있는 문법적 장치로 데이터의 표현에 매우 큰 도움을 준다. 예를 들어서 레이싱게임의 캐릭터로 등장하는 '자동차'를 표현한다고 가정해보자.
다음과 유사한 정보들이 모여서 게임상의 자동차가 표현되어야 한다.

  소유주
  연료량
  현재속도
  취득점수
  취득아이템

게임 사용자가 게임을 종료하면(로그아웃 화면), 위의 정보는 데이터베이스(또는 파일)에 함께 저장되어야 하며, 다시 게임을 시작하면(로그인 화면), 저장된 위의 정보는 모두 함께 복원되어야 한다.
따라서 이들 정보를 이용해서 다음과 같이 구조체를 정의하면 프로그래밍이 한결 수월해진다.

struct Car
{
    char gamerID[ID_LEN];         // 소유자ID, ID_LEN은 매크로 상수
    int fuelGauge;                // 연료량
    int curSpeed;                 // 현재속도
};

앞서 추출한 정보들 중 '취득점수'와 '취득아이템'을 제외한 나머지를 모두 포함하여 구조체로 정의하였다. 그럼 이어서 이 구조체를 기반으로 간단한 예제를 작성해 보겠다.
그런데 이에 앞서 C++에서의 구조체 변수 선언에 대한 이야기를 조금할 필요가 있다.


[C++에서의 구조체 변수의 선언]

C언어에서 구조체 변수를 선언하는 방법은 다음과 같다.

struct Car basicCar;
struct Car simpleCar;

앞에 삽입된 키워드 struct는 이어서 선언되는 자료형이 구조체를 기반으로 정의된 자료형임을 나타낸다.
그리고 키워드 struct를 생략하려면 별도의 typedef 선언을 추가해야 한다. 하지만 C++에서는 기본 자료형 변수의 선언방식이나 구조체를 기반으로 정의된 자료형의 변수 선언방식에 차이가 ㅇ벗다.
즉, C++에서는 별도의 typedef 선언 없이도 다음과 같이 변수를 선언할 수 있다.

Car basicCar;
Car simpleCar;

그럼 이어서 앞서 정의한 구조체를 기반으로 예제를 작성해보겠다.

ex) RacingCar.cpp
#include <iostream>
using namespace std;

#define ID_LEN 20          // 4 행
#define MAX_SPD 200
#define FUEL_STEP 2
#define ACC_STEP 10
#define BRK_STEP 10        // 8 행

struct Car
{
    char gamerID[ID_LEN];
    int fuelGauge;
    int curSpeed;
};

void ShowCarState(const Car &car)          // 17 행
{
    cout << "소유자ID: " << car.gamerID << endl;
    cout << "연료량: " << car.fuelGauge << '%' << endl;
    cout << "현재속도: " << car.curSpeed << "km/s" << endl << endl;
}

void Accel(Car &car)            // 24 행
{
    if(car.fuelGauge<=0)
        return;
    else
        car.fuelGauge-=FUEL_STEP;
        
    if(car.curSpeed+ACC_STEP >= MAX_SPD)
    {
        car.curSpeed = MAX_SPD;
        return;
    }    
    
    car.curSpeed += ACC_STEP;
}

void Break(Car &car)            // 40 행
{
    if(car.curSpeed <= BRK_STEP)
    {
        car.curSpeed = 0;
        return;
    }    
    
    car.curSpeed -= BRK_STEP;
}

int main(void)
{
    Car run99 = {"run99", 100, 0};              // 53 행
    Accel(run99);                                // 54 행
    Accel(run99);
    ShowCarState(run99);
    Break(run99);
    ShowCarState(run99);                        // 58 행
    
    Car sped77 = {"sped77", 100, 0};
    Accel(sped77);
    Break(sped77);
    ShowCarState(sped77);
    return 0;
}

해설
4 ~ 8 행 : 구조체 Car와 관련된 각종 정보를 상수화 하였다. 각각의 상수가 의미하는 바는 관련 함수를 통해서 이해 가능
17 행 : 차의 정보를 출력하는 기능의 함수이다. 단순히 정보를 출력만하기 때문에 const 참조자를 매개변수로 선언하였다.
24 행 : 차의 가속을 위해서 엑셀을 밟은 상황을 표현해 놓은 함수이다. 엑셀을 밟을 때마다 연료가 줄어들고 스피드가 올라가는 상황을 단순히 표현하였다.
40 행 : 브레이크를 밟은 상황을 표현한 함수. 브레이크도 연료의 소모가 동반되지만, 단순히 속도가 감속하는 것으로 표현.
53 행 : 구조체 변수의 선언 및 초기화가 진행.
45 ~ 58 행 : 엑셀과 브레이크를 밟은 상황을 연출.

결과
소유자ID: run99
연료량: 96%
현재속도: 20km/s

소유자ID: run99
연료량: 96%
현재속도: 10km/s

소유자ID: sped77
연료량: 98%
현재속도: 0km/s

함수는 결국 데이터의 처리를 담당하는 도구이니, 데이터와 함께 부류를 형성하는 것은 매우 당연하다.
따라서 필자는 위에 정의된 세 개의 함수에 대해 다음과 같이 이야기하고자 한다.

'구조체 Car와 함께 부류를 형성하여, Car와 관련된 데이터의 처리를 담당하는 함수들이다.'

따라서 위의 함수들은 구조체 Car에 종속적인 함수들이라고 말할 수 있다. 그럼에도 불구하고 전역함수의 형태를 띠기 때문에,
이 함수들이 구조체 Car에 종속적임을 나타내지 못하는 상황이다. 따라서 엉뚱하게도 다른 영역에서 이 함수를 호출하는 실수를 범할 수 있는 상황이다.


[구조체 안에 함수 삽입하기]

